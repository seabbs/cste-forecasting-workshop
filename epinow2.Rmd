---
title: Estimating reporting delays and nowcasting/forecasting infections with EpiNow2 using HHS COVID-19 hospitalizations
author: "Sam Abbott, Zachary Susswein, and Kaitlyn Gostic"
output:
  bookdown::html_document2:
    theme: cosmo
    toc: true
    toc_float: true
    toc_depth: 4
    number_sections: false
    code_folding: show
    css: html/style.css
    includes:
      before_body: html/header.html
      after_body: html/footer.html
    self_contained: true
    keep_md: false
date: "`r format(Sys.Date(), format = '%B %d, %Y')`"
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  message = FALSE,
  warning = FALSE,
  cache = TRUE
)
```

> &#128161; This tutorial is partly based on this [nowcasting example](https://github.com/epiforecasts/nowcasting.example) from Sam Abbott and Sebastian Funk.

# Outline

- In this tutorial we make use of [EpiNow2](https://epiforecasts.io/EpiNow2/), a toolset for real-time analysis of infectious disease dynamics, for estimating reporting delays and using them to conduct a nowcast. 
- We first explore the HSS hospitalization data and estimate the reporting delay distribution using `EpiNow2`.
- We then draw from the literature to define a plausible incubation period and reporting delay
- We then show how the these estimates may be used in `EpiNow2` to perform nowcasts, forecasts and estimation of reproduction numbers and growth rates. 
- Finally, we summarize strengths and weaknesses of this approach and highlight other options and areas for future work.

For more about the `EpiNow2` package see the [the package documentation](https://epiforecasts.io/EpiNow2/). An [alternative approach](https://package.epinowcast.org) to the problems discussed in this tutorial is contained in the `epinowcast` package. This package is still under active development but aims to address the limitations `EpiNow2` with a view to eventually replacing it.

# Getting started

## Using this tutorial

This tutorial is written in [R Markdown](https://rmarkdown.rstudio.com/) and can be run in [RStudio](https://www.rstudio.com/). See the `epinow2.Rmd` file for the code used to generate this tutorial, this is also the best place to start if you want to work through the tutorial yourself.

We also provide a [standalone HTML version](https://samabbott.co.uk/cste-forecasting-workshop/epinow2.html) of this tutorial that can be viewed in any web browser. This version is static and cannot be run interactively.

## Load required libraries

We first load the packages required for this tutorial. These can be installed or staged
```{r, eval = FALSE}
renv::restore()
```

> &#9888; **`The first run of renv::restore()` will take some time**: It is a command that will automatically install the correct versions of all packages needed to run this analysis. Ideally, we recommend running it sometime before you want to work through the rest of the tutorial. Once you have all the necessary packages installed, subsequent calls to `renv::restore()` should be quick. 


```{r init}
library("EpiNow2") # for estimating reporting delays and nowcasting
library("dplyr") # for manipulating data
library("ggplot2") # for plotting data
library("tidyr") # for manipulating data
library("purrr") # for manipulating data
library("covidcast") # for downlooading HHC hospitalization data
library("here") # for file paths
```

> &#128161; This tutorial depends on the development version of `EpiNow2`. You can see the documentation for the development version [here](https://epiforecasts.io/EpiNow2/dev/).

# Specify states of interest

To start, we want to examine trends from several states. 
Here, we focus on the data from New York, Utah, Ohio, Virginia, and North Carolina during the Omicron wave in winter 2021-2022.

```{r specify-states}
states_of_interest <- c("ny", "ut", "oh", "va", "nc")
```

If you're interested in looking at your state or adding some different states
for comparison, feel free to add an abbreviated state name to the vector above
in `epinow2.Rmd`.

# Load the data

We use the [covidcast](https://cmu-delphi.github.io/covidcast/covidcastR/) package to read in [HHS data](https://cmu-delphi.github.io/delphi-epidata/api/covidcast-signals/hhs.html) on confirmed Covid-19 hospital admissions. 
The primary source for these data is the HHS state-level COVID-19 hospitalization time series, which can be found on [HealthData.gov](https://healthdata.gov/Hospital/COVID-19-Reported-Patient-Impact-and-Hospital-Capa/g62h-syeh).
The [covidcast](https://cmu-delphi.github.io/covidcast/covidcastR/) package provides a convenient way to read in a subset of the full data set.
Here, we focus on the data from New York, Utah, Ohio, Virginia, and North Carolina during the Omicron wave in the winter of 2021-2022. 

We _could_ download the most recent version of this data directly using:

```{r, eval = FALSE, class.source = "fold-hide"}
covid_hospitalizations <- covidcast_signal(
      data_source = "hhs",
      signal = "confirmed_admissions_covid_1d",
      start_day = "2021-12-01",
      end_day = "2022-02-01",
      geo_type = "state",
      geo_value = states_of_interest
    ) |>
      as_tibble() |>
      filter(issue == max(issue)) |>
      select(geo_value, time_value, value) |>
      rename(state = geo_value, date = time_value, confirm = value)
```

The above command pulls the most up-to-date version of the data and stores it in a data frame called `covid_hospitalizations`.

But when evaluating methods, we're often interested in how they would have performed
on the data available at the time rather than the data in its final, fully-reported state.
This data format is equivalent to having a linelist with columns for the date of hospitalization and the date of report.

> &#128161; We use the terms **report date** and **vintage** to indicate the as-of date (on what date was this snapshot of the data observed). We use **event date** or simply **date** to indicate where a data point falls along the x-axis of the epidemic time series. 

> &#9888; **Don't run this command yourself if you don't have a [`covidcast` API key](https://cmu-delphi.github.io/covidcast/covidcastR/reference/covidcast_signal.html) key loaded**!. Instead go to the next step.


```{r, eval = FALSE, class.source = "fold-hide"}
# Define a range of as-of dates
as_of_dates <- seq(as.Date("2021-12-03"), as.Date("2022-03-01"), by = "day")

# Read in the data for each as-of date
covid_hospitalizations_by_vintage <- as_of_dates |>
  purrr::map_df(\(x) (
    covidcast_signal(
      data_source = "hhs",
      signal = "confirmed_admissions_covid_1d",
      start_day = "2021-12-01",
      end_day = "2022-02-01",
      as_of = x,
      geo_type = "state",
      geo_value = states_of_interest
    ) |>
      mutate(report_date = x) |> # Add the date of report
      select(report_date, geo_value, time_value, value) |> # keep these columns
      rename(state = geo_value, # rename the columns for readability
             date = time_value,
             confirm = value) |>
      arrange(date, report_date)
  )) |>
  as_tibble()
```

If you would like to run this command yourself, you can do so by removing the `eval = FALSE` from the above chunk after registering for a [`covidcast` API key](https://cmu-delphi.github.io/covidcast/covidcastR/reference/covidcast_signal.html) and loading it into R using `options(covidcast.auth = "<your-api-key>")`.

Rather make everyone get an API key and query the `covidcast` API themselves, we instead use the data we have already downloaded.

```{r}
# Read in the data, which are saved as a .rds file in the project folder
covid_hospitalizations <- readRDS(
  here("data", "covid_hospitalizations.rds")
) |>
  as_tibble()

glimpse(covid_hospitalizations)


covid_hospitalizations_by_vintage <- readRDS(
  here("data", "covid_hospitalizations_by_vintage.rds")
) |>
  as_tibble()

glimpse(covid_hospitalizations_by_vintage)
```

Before we proceed, we check that the data we have downloaded contains the states we're interested in.

```{r, class.source = "fold-hide"}
if (!all(states_of_interest %in% covid_hospitalizations$state) ||
    !all(states_of_interest %in% covid_hospitalizations_by_vintage$state)) {
  stop(
    "Not all states of interest are present in the data. ",
    "You may need to update the `states_of_interest` variable or ",
    "download the data again using the code in the previous chunks."
  )
}
```

# Data exploration

## Visualize hospitalizations

We start by visualizing the currently reported hospitalizations for this time period.
We're treating these reports as finalized because its unlikely there will be
substantial revisions in hospitalizations from so long ago.

```{r plot-obs, fig.height = 9}
covid_hospitalizations |>
  ggplot() +
  aes(x = date, y = confirm) +
  geom_col(alpha = 0.6) +
  theme_bw() +
  labs(
    x = "date of hospitalization",
    y = "incident hospitalizations",
    title = "hospitalizations in select sates for the winter 2021-2022 wave"
  ) +
  facet_wrap(vars(state), ncol = 1, scales = "free_y")
```

As expected we see a large increase in hospitalisations in all states during the winter 2021-2022 wave. However, we can also see that there is a large amount of variation in the number of hospitalisations reported on each date and state by state. 

## Visualise hosptialisations by date of report

Whilst it is interesting to look back retrospectively when analysing data it is important to remember that the data we have now is not the same as the data that was available at the time. This can occurr for a number of reasons, for example, there may be a delay between the date of hospitalisation and the date of report or there may be changes in how hospitalisations are measured which leads to a retrospective change in the number of hospitalisations.

To begin to unpick this we can look at the number of hospitalisations as it was reported. We should see that that the number of hospitalisations reported on each date increases over time as more data becomes available if the changes are caused only by delays. If reporting is more complex than this, for example, if hospitalisations can be recategorised to a different day then the number of hospitalisations reported for a given day may decrease as well as increase over time.

```{r plot-obs-vintage, fig.height = 9}
covid_hospitalizations |>
  ggplot() +
  aes(x = date, y = confirm) +
  geom_point(alpha = 0.6) +
  geom_line(
    data = covid_hospitalizations_by_vintage,
    aes(x = date, y = confirm, col = report_date, group = report_date),
    alpha = 0.8
  ) +
  scale_y_log10() +
  theme_bw() +
  labs(
    x = "Date of hospitalization",
    y = "Hospitalizations",
    title = "Hospitalizations in select states for the winter 2021-2022 wave"
  ) +
  guides(col = guide_colorbar(title = "Date of report", barwidth = 15)) +
  theme(legend.position = "bottom") +
  facet_wrap(vars(state), ncol = 1, scales = "free_y")
```

You should be able to see here that the data as observed in real time is right truncated, meaning that observations at the end of the time series are incomplete or subject to revision.
(The light blue line and points represent final counts. The short darker lines represent preliminary counts that will later be revised.)
In most epidemiological data, delays in reporting lead to a temporary undercount of what will eventually be reported. 
If left uncorrected when using real-time data sets, this truncation can lead to underestimation of the effective reproduction number, inaccurate forecasts, and potentially mislead reports policy makers using these metrics.

However, it appears that hospitalisations are also very commonly corrected down, this indicates a more complex reporting mechanism is at play. Unfortunately, currently currently there are few available methods that can address this kind of reporting structure and the development of new ones is likely dependent on the interaction between those collecting the data and those developing new methods.

## Visualize the reporting delay

We can also plot the distribution of reporting delays to look at how much delay is normal. 
For this plot, we calculate the delay between the date of hospitalization and the date of report for each hospitalization.

```{r plot-delay, fig.height = 9}
covid_hospitalizations_reporting_cdf <-
  covid_hospitalizations_by_vintage |>
  filter(date >= as.Date("2021-12-01")) |>
  group_by(date, state) |>
  group_modify(
    ~ mutate(.x,
      diff = confirm - lag(confirm, default = 0),
      final_reported = .x |>
        filter(report_date == max(report_date)) |>
        pull(confirm)
    )
  ) |>
  ungroup() |>
  mutate(
    delay = as.numeric(report_date - date),
    cdf = confirm / final_reported
  )

glimpse(covid_hospitalizations_reporting_cdf)

covid_hospitalizations_reporting_cdf |>
  filter(delay <= 10) |>
  ggplot() +
  aes(x = delay, y = cdf, group = date) +
  geom_step(alpha = 0.4) +
  theme_bw() +
  labs(
    x = "Reporting delay (days)",
    y = "Hospitalizations reported relative to the final count",
    title = "Reporting delay in select states for the winter 2021-2022 wave"
  ) +
  facet_wrap(vars(state), ncol = 1, scales = "free_y")
```

For the rest of this tutorial we focus on Ohio. You can repeat the analysis for other states by changing the following variable to the abbreviated state name you are interested in (e.g. "ca" for California).

```{r}
nowcast_state <- "oh"
```

> &#9888; **Note:** `nowcast_state` must be one of the states in `states of interest` above.

```{r, class.source = "fold-hide"}
# Check the data comtains the state of interest
if (!(nowcast_state %in% states_of_interest)) {
  stop("nowcast_state must be one of the states in states_of_interest")
}
```

# Estimating the reporting delay

## Using recorded data vintages for Ohio

We use `EpiNow2` to estimate the distribution of reporting delays for Ohio. 
The model in `EpiNow2` allow us to correct for right truncation in the data when we estimate the reproduction number. 
We restrict our data to data available between the 31st of December 2021 and the 14th of January 2022 as later we will nowcast for the 14th of January 2022 and so we want to use data that is relevant to this date.
Unfortunately, this model cannot account for over-reporting and so we will first have to remove this from the data.

```{r estimate_delays}
options(mc.cores = 4)

truncation_est <- covid_hospitalizations_reporting_cdf |>
  filter(state == nowcast_state) |>
  filter(date >= as.Date("2021-12-14")) |>
  filter(report_date >= as.Date("2021-12-31")) |>
  filter(report_date <= as.Date("2022-01-14")) |>
  group_by(date) |>
  mutate(confirm = max(confirm, dplyr::lag(confirm, default = 0))) |>
  ungroup() |>
  # Over the new year reporting was unusually delayed.
  # This leads to problems for the model
  filter(report_date != as.Date("2022-01-05")) |>
  select(report_date, date, confirm) |>
  group_split(report_date) |>
  map(~select(., -report_date)) |>
  estimate_truncation(
    trunc_max = 7,
    chains = 4, iter = 2000,
    control = list(adapt_delta = 0.99, max_treedepth = 15),
    verbose = FALSE
  )

## Make the output a dist_spec object
truncation_dist <- do.call(
  dist_spec, c(truncation_est$dist)
)
```

> &#9888; **This model may throw warnings about divergent transitions.** This is because the model is trying to estimate the truncation distribution for the data but there is very little truncation in the data. This is good news as it means we can use the data as observed to estimate the reproduction number. However, it does mean that `estimate_truncation()` won't work well (hence the warnings you may see when running the code) as it is designed to estimate the truncation distribution for data where truncation is present.

```{r plot-truncation}
plot(truncation_dist)
```

> &#9888; **This plot is empty because there is very little truncation in this data for this time period.** 

## Using synthetic vintages based on the latest data for Ohio

As we saw above, there is very little truncation in the data for Ohio for this time period. Because of this, we will instead use a synthetic data set to show how to use `estimate_truncation()` to estimate the distribution of reporting delays using the latest data from Ohio (as of the 14th of January 2022).

We first define a synthetic delay,

```{r synthetic-delay}
synth_truncation <- dist_spec(
  mean = 1.6, mean_sd = 0.025, sd = 0.5, sd_sd = 0.01, max = 15,
  distribution = "lognormal", fixed = FALSE
)
synth_truncation
```

Which we can then plot to see what it looks like,

```{r plot-synthetic-delay}
plot(synth_truncation)
```

Now we use this to generate a synthetic data set by combining it with the latest data from Ohio (as of the 14th of January 2022).

```{r define-simulator-for-truncation, class.source = "fold-hide"}
simulate_truncation <- function(index, cases, dist) {
  set.seed(index)
  cmf <- cumsum(
    dlnorm(
      1:(dist$max + 1),
      rnorm(1, dist$mean_mean, dist$mean_sd),
      rnorm(1, dist$sd_mean, dist$sd_sd)
    )
  )
  cmf <- cmf / cmf[dist$max + 1]
  cmf <- rev(cmf)[-1]
  if (nrow(cases) < index + length(cmf)) {
    stop(
      "Not enough data to construct a synthetic data set with this ",
      "truncation distribution and index."
    )
  }
  untrunc_cases <- cases |>
    slice_head(n = nrow(cases) - index - length(cmf))

  trunc_cases <- cases |>
    slice_head(n = nrow(cases) - index) |>
    slice_tail(n = length(cmf)) |>
    mutate(confirm = as.integer(confirm * cmf))

  cases <- bind_rows(
    untrunc_cases,
    trunc_cases
  )
  return(cases)
}
```

```{r synthetic-delays}
synth_truncated_hosp <- map(c(20, 15, 10, 5, 4, 2, 1, 0),
  simulate_truncation,
  cases = covid_hospitalizations |>
    filter(state == nowcast_state) |>
    select(-state),
  dist = synth_truncation
)
```

We can now use `estimate_truncation()` to estimate the distribution of reporting delays for this synthetic data set.

```{r estimate-synthetic-delays}
syn_trunc_est <- estimate_truncation(
  synth_truncated_hosp,
  trunc_max = 15,
  chains = 4, iter = 2000,
  control = list(adapt_delta = 0.99, max_treedepth = 15),
  verbose = FALSE
)
```

Plotting the model predictions compared to synthetic data we can see that the model does a good job of reconstructing the data that will be observed in this synthetic example (we can see this as  the earliest data points have been observed fully and so can be compared to the model predictions directly).

```{r plot-synthetic-delays}
plot(syn_trunc_est)
```

Finally we can extract and plot the estimated reporting distribution,

```{r estimated-synth-delay}
est_synth_trunc_dist <- do.call(
  dist_spec, syn_trunc_est$dist
)

est_synth_trunc_dist

plot(est_synth_trunc_dist)
```

As expected for this synthetic example, the estimated distribution is very similar to the true distribution used to generate the data.

# Getting ready to nowcast

## Generation time estimate

The generation time is the time between infection of an individual and infection of their infector.
In order to estimate the effective reproduction number with the renewal equation we need an estimate of the generation time.
With this quantity, we relate the number of infections on day $t$ to the number of infections on day $t - \tau$ where $\tau$ is the index of the generation time distribution. Mathematically this is

$$ I_t = R_t \sum_{tau = 1}^T I_{t - \tau} G(\tau), $$

where $T$ is the maximum length of the generation time. 
Rather than estimating the generation time here, we instead use an estimate from the literature. 
Specifically we use an estimate from [Ganyani et al. (2020)](https://doi.org/10.2807%2F1560-7917.ES.2020.25.17.2000257) which is based on a few hundred cases of COVID-19 in China.
For a real-world analysis we recommend thinking carefully about which generation time distribution to use. 
For example, the [Ganyani et al. (2020)](https://doi.org/10.2807%2F1560-7917.ES.2020.25.17.2000257) estimate is based on a sample of cases from China and so may not be representative of the generation time in other settings.

```{r}
generation_time <- get_generation_time(
  disease = "SARS-CoV-2", source = "ganyani",
  max = 10, fixed = TRUE
)
generation_time
```

We can now visualize this distribution.

```{r}
plot(generation_time)
```

The dark bars show a histogram of the generation time probabilities by day. The step plot shows the cumulative probability.

## Delays from infection to hospitalization

The delay between infection and hospitalization can be decomposed into two distributions: the incubation period and the delay from symptom onset to hospitalization. We can estimate these distributions using `EpiNow2` but for this tutorial we will use estimates from the literature.

### Incubation period

The incubation period is the time between infection and symptom onset. Here we use an estimate from [Lauer et al. (2020)](https://doi.org/10.7326%2FM20-0504) which is based on a few hundred cases of COVID-19 in China. For a real-world analysis we recommend thinking carefully about which incubation period distribution, just as we did for the generation time.

```{r}
incubation_period <- get_incubation_period(
  disease = "SARS-CoV-2", source = "lauer", fixed = TRUE,
  max = 15
)
incubation_period
```

We can now visualize this distribution.

```{r}
plot(incubation_period)
```

### Delay from symptom onset to hospitalization

The delay from symptom onset to hospitalization is the time between symptom onset and hospital admission. This time typically depends on the severity of symptoms, the robustness of the health system and the behavior of the individual. Here we use a toy estimate but ideally data would be available to estimate this quantity.

```{r}
## Delay from symptom onset to report
reporting_delay <- dist_spec(
  mean = convert_to_logmean(3, 1),
  sd = convert_to_logsd(3, 1),
  max = 10
)
reporting_delay
```

We can again visualize this distribution.

```{r}
plot(reporting_delay)
```

### Convolving the delay from infection to hospitalization

As the incubation period and reporting delay can be represented as probability mass functions (i.e., vectors of probabilities) we can convolve them to find the distribution of delays from infection to hospitalization.
(Convolution is the mathematical operation used to add random variables together. Essentially, we are adding the incubation and reporting delay distributions. Normally you wouldn't be able to add two distributions together with a plus sign, but `EpiNow2` provides special functionality that lets us do this.)
Calculating this convolution outside of the model helps reduce the computational burden as we do not need to account for multiple delays.
It is also useful as it allows us to understand the combined effect of the incubation period and reporting delay on the delay from infection to hospitalisation.

```{r}
inf_to_hospitalization <- incubation_period + reporting_delay
```

We can now plot this convolved distribution.

```{r}
plot(inf_to_hospitalization)
```

# Putting it all together into a nowcast

Now we have all the components we need to construct a nowcast. First we construct the data set of hospitalizations we wish to nowcast using data as available on the 14th of January 2022.

```{r}
oh_hosp_14th <- covid_hospitalizations_by_vintage |>
  filter(state == nowcast_state) |>
  filter(report_date == as.Date("2022-01-14")) |>
  select(date, confirm)

glimpse(oh_hosp_14th)
```

In order to evaluate our model we will use the most recently reported data up to the 28th of January 2022 (as we are forecasting for a week).

```{r}
oh_hosp_28th_retro <- covid_hospitalizations |>
  filter(state == nowcast_state) |>
  filter(date <= as.Date("2022-01-28")) |>
  select(date, confirm)
```

We then use the `estimate_infections()` function contained in `EpiNow2` on this data set to obtain a nowcast, forecast and reproduction number estimate.
This model uses a renewal equation based method to estimate the reproduction number and then convolves this with the incubation period and reporting delay we defined earlier to obtain a nowcast.
It generates a forecast extrapolating the reproduction number estimate into the future. This is just an example model as there are many other ways to estimate the reproduction number and many other ways to extrapolate it into the future. We recommend thinking carefully about which model to use for your analysis.

> &#128161; We haven't adjusted for truncation as there was little evidence of truncation in the weeks directly before this date.
 
```{r estimate_infections}
options(mc.cores = 4)

rt_estimates <- estimate_infections(
  reported_cases = oh_hosp_14th,
  # Our generation time estimate is first preprocessed into a format the model
  # understands
  generation_time = generation_time_opts(generation_time),
  # Similarly our delay from infection to hospitalisation is also preprocessed.
  delays = delay_opts(inf_to_hospitalization),
  rt = rt_opts(
    # Here we specify a prior for the initial value of the reproduction number
    # We set this to be near 1 as we expect the epidemic to be growing slowly
    # at the start of the period of interest
    prior = list(mean = 1, sd = 0.1),
    # This indicates the period of the random walk we wish to use (7 days).
    rw = 7
  ),
  # Here we have turned off the default Gaussian process prior in favor of 
  # the random walk specified in rt_opts.
  # This speeds up the code.
  gp = NULL,
  # These options control the MCMC sampler used to estimate the posterior
  # This uses the No-U-Turn sampler with a target acceptance rate of 99%
  # and 2000 samples with 500 warmup iterations.
  stan = stan_opts(
    control = list(adapt_delta = 0.99),
    samples = 2000, warmup = 500
  ),
  # These options tell the model to use a Poisson error structure, and to
  # adjust for day-of-week effects
  obs = obs_opts(
    family = "poisson", week_effect = TRUE
  ),
  # We set a 14 day forecast horizon
  horizon = 14
)
```

> &#9888; The Omicron wave was a very different to previous waves of COVID-19 and is very challenging to model due to changes in infectiousness, severity and testing. We recommend using caution when interpreting these results.

# Visualising the resulting nowcast

## Effective reproduction number estimates

Using the output of `estimate_infections()` we can visualise the effective reproduction number estimates using a call to `plot()` (this has a range of other plotting options which can be explored using `?EpiNow2:::plot.estimate_infections`). Because we specified a weekly random walk for $R_t$, our estimates show weekly steps.

```{r plot_rt}
plot(rt_estimates, type = "R")
```

## Estimated latent hospitalizations by date of infection

We can also plot the estimated latent hospitalizations by date of infection. 
This is useful as it allows us to get a sense for the number of infections after accounting for delays from infection to hospitalization.

> &#128161; This plot shows **hospitalizations by date of infection** not an estimate of **infections by date of infection**. This is because we are using hospitalizations as a proxy for infections without adjusting for the **infection to hospitalization** ratio. We could do this by specifying a value for `scale` in `obs_opts()` if we had a good estimate of this ratio.

```{r plot_infections}
plot(rt_estimates, type = "infections")
```

## Predicted hospitalizations

Another useful plot is the predicted hospitalisations. This can be obtained using the `plot_estimates()` function. This function takes a data frame of estimates and a data frame of reported cases and plots the estimates alongside the reported cases. 

Whilst the forecast is useful it is important to note that it is based on the assumption that the reproduction number remains constant at the last estimated value (though other options are supported in the package). This is unlikely to always be true in practice and so the forecast should be communicated with this in mind. 

```{r plot_hospitalizations}
rt_estimates |>
  pluck("summarised") |>
  filter(variable %in% "reported_cases") |>
  plot_estimates(
    reported = oh_hosp_28th_retro
  )
```

We see that the forecast performs relatively well when compared to more recent data.

# Summary

- We have shown how to use `EpiNow2` to estimate the effective reproduction number and forecast hospitalisations.
- We have also explored how to use `EpiNow2` to estimate the delay from infection to hospitalisation.
- Finally, we have discussed some limitations of the approach and how to communicate these.

## Strengths

- The approach provides estimates for reproduction numbers, growth rates, and forecasts future hospitalizations using available data and accounting for real-world data issues.
- The tutorial provides detailed guidance on how to estimate reporting delays which can be diffucult using traditional methods due to right truncation.
- `EpiNow2` uses a renewal equation based method to estimate the reproduction number and convolves this with the incubation period and reporting delay to obtain a nowcast and forecast future hospitalizations. This approach has been widely used in the literature and is relatively easy to understand.

## Limitations 

- The estimates may be affected by changes in hospitalization measures that lead to retrospective changes in the data. 
- The approach requires data on hospitalizations, but does not adjust for infection to hospitalization ratio, meaning that the results should be interpreted as estimates of hospitalizations rather than infections.

## Other resources

If you are interested in finding additional resources for estimating the effective reproduction number or learning about nowcasting in R, explore the following:

- [EpiNow2 website](https://epiforecasts.io/EpiNow2/dev): The documentation for the `EpiNow2` package. This is the package we will be using in this tutorial. It is designed to be easy to use, robust to a wide range of contexts, and flexible.
- [epinowcast](https://package.epinowcast.org): This package has been designed as the successor to `EpiNow2` and is currently under development. It is designed to be more general and even more flexible than `EpiNow2`.
- [epidemia](https://imperialcollegelondon.github.io/epidemia/index.html): This is another flexible package for estimating the effective reproduction number and forecasting. It is designed to be more flexible than `EpiNow2` and `epinowcast` but is potentially more difficult to use. It also generally has less functionality for dealing with delays than `EpiNow2` and `epinowcast`.
- [EpiEstim](https://cran.r-project.org/web/packages/EpiEstim/index.html): This is a more mature package for estimating the effective reproduction number. It exploits a mathematically relationship to fit the renewal equation very quickly but is not currently able to handle reporting delays or to produce forecasts which the use of supporting packages.
